# webapp
  创建一个购物webapp,首页,购物车,分类,我的,这是几个基本页面,
  布局使用弹性盒布局优先构建首页
## 准备工作
  使用vue脚手架(cli)先创建vue2.0的项目,把router和vuex勾选上,顺便勾选上stylus方便书写css,考虑要使用ajax请求,所以使用vue官方推荐的axios,可以在安装完成项目的时候创建文件夹utils,在utils里面新建一个axios.js的文件夹,在里面导入axios,并且设置请求路径,这边可以设置一个变量判断环境是开发环境还是生产环境,通过判断环境给予不同的请求地址,baseURL这边进行判断,在文件里面还需要把axios的请求拦截器和响应拦截器,写入进来方便接口调试,以及根据返回值进行操作,或者给请求添加token操作,做完更改后需要抛出方便使用,配置完成之后还需要到最外层手动新建一个vue.config.js,在里面devServer添加proxy进行一下跨域的设置,以对象的方式进行配置,里面的键/api就是target的别名,会把请求的/api替换成对应的地址,做完这些之后我们还需要配置一下视口,我们直接把html根元素的font-size设置为26.6666vm这样方便进行计算,我们这边使用rem进行布局,根元素的计算是100 / 375 * 100,做完这些配置就可以开始项目构建了
## 路由以及app页面构建
进入app.vue 把template里面删除,我们只需要在里面写入一个router-view即可,之后的页面都是通过这个进行显示的,现在我们需要去配置路由,找到路由,path配置到时候,在url通过什么访问,注意需要```/```但是嵌套路由不需要,也不能加,加上之后就不是嵌套路由了,可以根据需求增加懒加载
## 首页
  ### 头部构建
  布局使用头部和底部固定,中间内容自适应,
  这边通过观察发现头部全都是跳转新页面,
  所以这边通过vant使用icon组件找多相应的icon
  设置头部左边图标,中间使用一个div给其内部设置icon以及文字,给div设置弹性盒,设置属性让其居中,再给div设置border-radius这样可以获得一个圆角的输入框,但是实际上这个是不能输入的,点击之后会跳转到search页面,最后构建右边的登录,这边也是通过div,里面放两个h2为了实现之后的登录和用户名字显示的效果,通过v-if或者v-show来进行显示的控制,如果用户登录就显示用户名,否则就是登录,这边需要注意的click事件写在div不太好,需要写比较不好阅读的代码,所以这边可以直接写在h2标签上,对应的跳转地址,如果是登录就跳转到,/login页面上,如果是用户名可以跳转到/user里面
  ### 底部构建
  底部直接通过把div转成弹性盒,使用vant的icon以及文字,设置垂直水平居中,高度设置为50px,设置完成之后,可以直接把它写成组件,抽离出来,这样方便之后使用,因为需要考虑一些页面是没有底部的tabbar,这个时候可以在src里面新建一个components放一些组件,这边我们把底部抽离出来,写在一个叫Tabbar的组件里面,这个时候需要吧ul里面的li换成router-link通过,tag再把默认的a标签换成li这样就不需要改变css
  ### 内容构建
  #### 轮播图
  首先需要构建轮播图,这边使用vant的swipe来实现轮播图,数据获取获取,这边通过在utlis里面新建一个index.js文件来放要使用的请求,开始需要导入之前写好的axios,然后直接在里面写上请求地址根据接口文档,看是否需要传参和接口类型,注意:GET要使用对象形式,默认就是GET请求```request```,POST请求要主要不能直接写,需要写成```request.post```形式,参数是地址,和参数,注意参数要使用params.
  写好之后可以回到home继续书写,轮播图数据需要一开始就展示出来所以可以把ajax放到created 或者 mounted中,每次进入页面就发送一次请求,把请求出来的数据,通过v-for渲染到页面上,这个时候需要主要两点,第一为了页面的优化(性能优化),可以加上key,但是key尽量不要使用index,除非没有id可以使用可以使用index,这边碰上另外问题,如果接口传递过来的图片没有地址或者失效，这个时候我们可以在获取数据的时候进行遍历或者可以在渲染时候给img写一个三元进行判断,如果没有就给一个默认图片
  #### 导航
  导航是通过vant的grid,来实现,先在utils/index.js添加接口请求,让后只需要使用数据进行渲染即可,这边使用的是v-for渲染的
  #### 秒杀商品
  通过观察可以发现,有商品还有倒计时,这边我们可以先通过给utils/index.js添加秒杀商品的请求,获取到商品数据之后通过v-for进行渲染,主要这边渲染时候需要计算原价打折之后的价格,可以直接写在模板中,也可以通过计算属性去实现,现在需要实现的就是秒杀的倒计时时间,我们可以拿现在时间小时取余数来进行判断奇数偶数,如果是偶数,就用当前时间小时加上2小时,获得时间,再通过计算出来的时间减去现在时间的时间戳,如果是奇数就加1小时,这样就完成了秒杀时间倒计数的实现
  #### 商品列表
  因为考虑多个地方需要使用进行抽离,单独设置成组件,这里要使用到两种排列的方法,所以这边开始写好这两种样式,通过一个变量控制切换,所以需要一个按钮或者标签来控制这个变量,这样就可以实现点击按钮或者标签,切换试图排列,这边因为是抽离出来的组件所以要考虑数据来源,所以使用了props来获取数据,这样大大提高了组件的复用性,也可以使用vuex来传递数据,拿到数据之后只需要进行渲染即可,这边使用ul和li,v-for尽量给li,这个时候还需要给li一个点击事件,因为之后需要点击,带产品id进入详情页面
  ## 商品详情
  商品头部是需要返回按钮所以,导入vant使用ul库里面navbar来实现,导入之后在template使用即可,图片展示也有对应的组件,可以通过swipe组件实现滑动,里面在使用overlay可以实现大图预览,只需要使用通过接口获取过来的数据,这边需要我们自己进行数据处理,因为数据图片,是一条,通过逗号分割我们直接通过string方法split进行分割,这样就可以获取到图片,商品信息渲染,也只需要拿到接口数据进行渲染即可,但是底部tabbar,使用vant的goods组件,但是需要注意的有些数据是已下架,所以无法点击已经购买的,思路是增加一个按钮,如果没下架,就隐藏起来显示立即购买,反之显示已下架,隐藏立即购买,可以通过数据判断,购物车以及加入购物车都需要加以判断,如果localstorage的islogin有而且是true就给跳转否则不跳转,但是这样需要给两个都添加这个判断,还可以使用路由守卫来判断,这样只需书写一次,其他页面如果也要跳转的也不需要重复书写.如果已经登录,这样需要把当前商品数据添加到当前用户的购物车里面,也就是发送请求给数据库,让数据增加,如果没有登录,则跳转到登录页面,让用户登录
  ## 分类
  头部使用vant的navbar来实现,分类页面使用左边大品类固定,每次点击左边大品类出现该品类下对应的小品类,左边可以使用vant里面sidebar进行,这边需要主要的是头部以及底部固定,不然会出现内容把底部tabber撑到最底下,导致看不到,为了防止这种情况需要给左边加上overflow-y auto即可实现,此时父元素需要overflew hidden这样不会出现撑到底,此时我们需要给左侧添加点击事件,每次点击就会发送请求,使用大品类,去获取小品类,然后进行渲染,需要注意开始进来是没有点击所以不会调用方法去获取小品类,这时我们需要在mounted的中手动调用一次,这样就可以解决进入小品类空白问题
  ## 购物车
  查看购物车发现头部需要有返回,因底部已经没有跳转的,底部已经变成提交以及合计的tabbar所以,商品卡片也可以通过vant里面的来实现,这边主要要实现的勾选商品显示价格,以及全选和猜你喜欢,进入使用mounted获取购物车数据,在商品卡片上进行渲染,每个卡片左边都有一个复选框,给每个复选框加上点击事件,传index参数,每次点击触发,触发之后使用index获取到那个商品需要勾选,数据传给数据库,并且在底部tabber的全选添加一个计算属性,里面通过数组every,每次点击都遍历一遍,来判断是否为真,如果为真就全选,如果一个不为真就为假,这边还有全选和全不选需要实现,可以通过点击事件,如果当前计算属性为真,点击之后先调用接口把数据库的数据改变,然后在通过map或者foreach进行遍历给所有的给false,如果为假,则相反,这样就可以实现,也可以使用状态管理的getters 或者 watch实现,给提交订单,添加跳转以及生成订单,猜你喜欢只需要导入之前封装好的商品列表组件,数据通过获取推荐产品数据渲染即可,商品数量加减只需要给步进器添加事件调用更改购物车数量接口改变数据即可
  ## 个人中心
  底部是有tabber使用自己封装的,头部是有头像和用户名需要渲染,数据通过获取用户信息接口获取到,头部还需要添加一个设置图标,并且添加点击事件方便跳转到设置页面,在下面div添加4个icon图标,每个都设置点击之后不同的功能,运输点击之后会弹出popup组件,这个组件设置在bottom可以在下方弹出,弹出之后里面显示的就是物流情况,通过组件Steps实现类似快递物流的效果,数据是通过订单的信息里面数据拼接出的地址,地址图标是直接跳转添加地址页面,购物车图标则是直接跳转到购物车,可以通过获取购物车列表,来实现在购物车上显示购物车商品数量,地址以及我的订单也可以如此
  ## 设置页面
  头部使用navbar,底部有一个button的退出登录按钮使用absolute然后设置buttom为0让他保持底部,点击之后会清空localstorage里面islogin以及token,和userid,内容有两个div,第一个是绑定用户名,第二个是修改密码,
  通过查看接口得知,需要参数一样,说明可以复用同一个输入框,设置一个flag来判断,点击绑定用户时,弹出输入框,这是把flag设置为true,反之设置为false,弹出的输入框通过判断flag来选在调用那个接口,即可
  ## 搜索页面
  搜索页面构成主要是搜索框,浏览记录以及热门搜索,这边头部直接可以把首页的头部搜索拿过来进行改造,把左侧图标换成返回按钮,把登录换成搜索按钮,中间的div换成一个可以输入的input框这边输入框使用的vant的Search,现在只需要构建热门搜索了,这边可以直接调用接口把数据拿过来进行渲染,可以考虑使用vantage的Button来放数据,给每个buttom直接加上间距,使其不至于粘滞一起,浏览记录,直接把热门搜索样式以及结构拿过来即可,只需而外在右侧加上一个垃圾桶的icon图表,需要改造地方是数据源获取,以及显示和隐藏,通过观察可以把数据存在localstorage里面以数组的方式,这样方便存储,给搜索添加事件,每次点击准备跳转前,先把搜索框里面的数据存入本地,这里需要注意如果已经有相同数据,需要先删除然后写入到最前面,还需要注意数据的存储,因为数据是放在localstorage里面,采用是json格式写入和取出的时候要转换.然后只需要在浏览记录上添加判断,判断localstorage里面是否有数据,有就显示并且使用,没有就不显示.这样就完成了浏览记录的功能
  ## 搜索商品页面
  头部直接可以使用搜索的头部,头部下方有筛选以及排序,使用vant的DropdownMenu可以实现样式,给第一个添加价格升序和降序功能,默认是综合,如果是默认就是把请求出来的数据按照原样输出,排序可以使用sort这个数组方法,升序使用a-b即可,降序反之b-a,这边需要用一个新的数组接受获取过来的数据,这样就不会变化原来的数组,复制的时候需要使用深复制,不然还是会改变原来数据,第二个销量也是如此,只需要把相应价格改成销量即可,价格筛选通过两个input框和一个按钮组成,点击的时候只需要通过every进行筛选即可,这样就会返回所有满足条件的数据,商品展示只需要通过调用自己封装好的prolist这个组件即可,用新数组给prolist传参即可完成,这个页面可以复用,分类和搜索都可以使用此页面,通过在状态管理里面设置一个Boolean值通过控制true或者false来决定调用哪个接口
  ## 填写订单
  头部还是还是使用vant的NavBar只需要吧titel改成填写订单即可,头部下面需要显示当前地址可以使用AddressList这个组件显示,这边涉及到使用那个地址问题,这边使用的处理方法是使用状态管理state里面,每次进入页面先判断是否有,有的话就通过请求获取过来的数据进行筛选id相同的数据信息,如果没有在通过接口请求默认地址,判断是否存在默认地址,如果有就直接使用,如果没有在直接拿数据最后一条即可,因为接口添加地址数据时候追加这种方式,所以最新添加的数据都在最后,如果一开始请求就没有的话就会使用默认空的数据,并且通过Dialog组件弹窗提示用户没有地址,询问是否跳转页面进入添加地址页面.订单商品使用Card组件渲染出来即可,下方去支付,可以直接使用,购物车的,总价可以和购物车一样使用计算属性,用数量乘以价格,这样就可以获得总价格.
  ## 地址管理
  这边可以使用和订单页面一样的头部, 只需要修改titel,地址的显示和下方新增地址可以直接使用vant的AddressList进行实现,这边需要考虑的是数据的新增和修改,以及选择想要使用的地址,先获取数据,发现渲染出来没有地址,通过查看文档得知需要address参数,但是接口没有直接提供,这边需要自己手动拼接,然后还发现如果需要有勾选需要id这个属性,可以address和id同时进行渲染,这样地址就显示出来了,现在需要增加新增功能和修改功能,可以使用Popup弹出层,从下弹出,弹出层内部放AddressEdit地址编辑,添加点击事件,当点击新增时候就会从下方弹出,这个和修改要的参数基本上一样所以可以复用,可以使用一个flag来控制文字显示已经请求接口的变化,如果点击的新增,则里面的保存按钮事件也不一样,保存是新增并且跳回订单页面,如果是点修改弹出,则是显示修改文字,点击之后不会跳转到订单页面,如果需要手动使用想要使用的地址,则只需要勾选想要使用的地址,通过获取勾选的index获取对应的addressid并且存放到状态管理中,即可,删除也通过index获取对应的addressid进行删除
